// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: product.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/tabbed/pqtype"
)

const getCategories = `-- name: GetCategories :many
SELECT id, name, description, create_uid, write_uid, create_date, write_date
FROM category
WHERE CASE WHEN array_length($1::int8[], 1) > 0 THEN id = ANY($1::int8[]) ELSE TRUE END
`

func (q *Queries) GetCategories(ctx context.Context, ids []int64) ([]Category, error) {
	rows, err := q.query(ctx, q.getCategoriesStmt, getCategories, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreateUid,
			&i.WriteUid,
			&i.CreateDate,
			&i.WriteDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductAndRelations = `-- name: GetProductAndRelations :many
SELECT p.id, p.template_id, p.name, p.origin_price, p.sale_price, p.state, p.variants, p.create_uid, p.write_uid, p.create_date, p.write_date, c.id category_id, u.id uom_id, s.id seller_id
FROM product p
JOIN product_template pt on pt.id = p.template_id
JOIN category c on c.id = pt.category_id
JOIN uom u on u.id = pt.uom_id
JOIN seller s on s.id = pt.seller_id
WHERE CASE WHEN array_length($1::int8[], 1) > 0 THEN p.id = ANY($1::int8[]) ELSE TRUE END
`

type GetProductAndRelationsRow struct {
	ID          int64                 `json:"id"`
	TemplateID  sql.NullInt64         `json:"template_id"`
	Name        string                `json:"name"`
	OriginPrice float64               `json:"origin_price"`
	SalePrice   float64               `json:"sale_price"`
	State       string                `json:"state"`
	Variants    pqtype.NullRawMessage `json:"variants"`
	CreateUid   int64                 `json:"create_uid"`
	WriteUid    int64                 `json:"write_uid"`
	CreateDate  time.Time             `json:"create_date"`
	WriteDate   time.Time             `json:"write_date"`
	CategoryID  int64                 `json:"category_id"`
	UomID       int64                 `json:"uom_id"`
	SellerID    int64                 `json:"seller_id"`
}

func (q *Queries) GetProductAndRelations(ctx context.Context, ids []int64) ([]GetProductAndRelationsRow, error) {
	rows, err := q.query(ctx, q.getProductAndRelationsStmt, getProductAndRelations, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductAndRelationsRow{}
	for rows.Next() {
		var i GetProductAndRelationsRow
		if err := rows.Scan(
			&i.ID,
			&i.TemplateID,
			&i.Name,
			&i.OriginPrice,
			&i.SalePrice,
			&i.State,
			&i.Variants,
			&i.CreateUid,
			&i.WriteUid,
			&i.CreateDate,
			&i.WriteDate,
			&i.CategoryID,
			&i.UomID,
			&i.SellerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductDetails = `-- name: GetProductDetails :many
SELECT p.id, p.template_id, p.name, p.origin_price, p.sale_price, p.state, p.variants, p.create_uid, p.write_uid, p.create_date, p.write_date,
       c.id category_id, c.name category_name,
       u.id uom_id, u.name uom_name,
       s.id seller_id, s.name seller_name, s.logo_url seller_logo, s.address seller_address,
       pt.name template_name, pt.rating, pt.number_rating, pt.description template_description, pt.remain_quantity, pt.sold_quantity,
       us1."name" create_name, us2."name" write_name
FROM product p
JOIN product_template pt on pt.id = p.template_id
JOIN category c on c.id = pt.category_id
JOIN uom u on u.id = pt.uom_id
JOIN seller s on s.id = pt.seller_id
LEFT JOIN "user" us1 on us1.id = p.create_uid
LEFT JOIN "user" us2 on us2.id = p.write_uid
WHERE CASE WHEN array_length($1::int8[], 1) > 0 THEN p.id = ANY($1::int8[]) ELSE TRUE END
`

type GetProductDetailsRow struct {
	ID                  int64                 `json:"id"`
	TemplateID          sql.NullInt64         `json:"template_id"`
	Name                string                `json:"name"`
	OriginPrice         float64               `json:"origin_price"`
	SalePrice           float64               `json:"sale_price"`
	State               string                `json:"state"`
	Variants            pqtype.NullRawMessage `json:"variants"`
	CreateUid           int64                 `json:"create_uid"`
	WriteUid            int64                 `json:"write_uid"`
	CreateDate          time.Time             `json:"create_date"`
	WriteDate           time.Time             `json:"write_date"`
	CategoryID          int64                 `json:"category_id"`
	CategoryName        string                `json:"category_name"`
	UomID               int64                 `json:"uom_id"`
	UomName             string                `json:"uom_name"`
	SellerID            int64                 `json:"seller_id"`
	SellerName          string                `json:"seller_name"`
	SellerLogo          sql.NullString        `json:"seller_logo"`
	SellerAddress       sql.NullString        `json:"seller_address"`
	TemplateName        string                `json:"template_name"`
	Rating              float64               `json:"rating"`
	NumberRating        int64                 `json:"number_rating"`
	TemplateDescription sql.NullString        `json:"template_description"`
	RemainQuantity      float64               `json:"remain_quantity"`
	SoldQuantity        float64               `json:"sold_quantity"`
	CreateName          sql.NullString        `json:"create_name"`
	WriteName           sql.NullString        `json:"write_name"`
}

func (q *Queries) GetProductDetails(ctx context.Context, ids []int64) ([]GetProductDetailsRow, error) {
	rows, err := q.query(ctx, q.getProductDetailsStmt, getProductDetails, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductDetailsRow{}
	for rows.Next() {
		var i GetProductDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.TemplateID,
			&i.Name,
			&i.OriginPrice,
			&i.SalePrice,
			&i.State,
			&i.Variants,
			&i.CreateUid,
			&i.WriteUid,
			&i.CreateDate,
			&i.WriteDate,
			&i.CategoryID,
			&i.CategoryName,
			&i.UomID,
			&i.UomName,
			&i.SellerID,
			&i.SellerName,
			&i.SellerLogo,
			&i.SellerAddress,
			&i.TemplateName,
			&i.Rating,
			&i.NumberRating,
			&i.TemplateDescription,
			&i.RemainQuantity,
			&i.SoldQuantity,
			&i.CreateName,
			&i.WriteName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductTemplates = `-- name: GetProductTemplates :many
SELECT id, name, description, default_price, remain_quantity, sold_quantity, rating, number_rating, create_uid, write_uid, create_date, write_date, variants, seller_id, category_id, uom_id
FROM product_template
WHERE CASE WHEN array_length($1::int8[], 1) > 0 THEN id = ANY($1::int8[]) ELSE TRUE END
`

func (q *Queries) GetProductTemplates(ctx context.Context, ids []int64) ([]ProductTemplate, error) {
	rows, err := q.query(ctx, q.getProductTemplatesStmt, getProductTemplates, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductTemplate{}
	for rows.Next() {
		var i ProductTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DefaultPrice,
			&i.RemainQuantity,
			&i.SoldQuantity,
			&i.Rating,
			&i.NumberRating,
			&i.CreateUid,
			&i.WriteUid,
			&i.CreateDate,
			&i.WriteDate,
			&i.Variants,
			&i.SellerID,
			&i.CategoryID,
			&i.UomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProducts = `-- name: GetProducts :many
SELECT id, template_id, name, origin_price, sale_price, state, variants, create_uid, write_uid, create_date, write_date
FROM product
WHERE CASE WHEN array_length($1::int8[], 1) > 0 THEN id = ANY($1::int8[]) ELSE TRUE END
`

func (q *Queries) GetProducts(ctx context.Context, ids []int64) ([]Product, error) {
	rows, err := q.query(ctx, q.getProductsStmt, getProducts, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.TemplateID,
			&i.Name,
			&i.OriginPrice,
			&i.SalePrice,
			&i.State,
			&i.Variants,
			&i.CreateUid,
			&i.WriteUid,
			&i.CreateDate,
			&i.WriteDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByKeyword = `-- name: GetProductsByKeyword :many
SELECT id, COUNT(*) OVER() total
FROM product
WHERE CASE WHEN CHAR_LENGTH($1::varchar) > 0 THEN "name" LIKE $1::varchar ELSE TRUE END
ORDER BY id DESC
OFFSET $2::int8
LIMIT $3::int8
`

type GetProductsByKeywordParams struct {
	Keyword string `json:"keyword"`
	Offset  int64  `json:"_offset"`
	Limit   int64  `json:"_limit"`
}

type GetProductsByKeywordRow struct {
	ID    int64 `json:"id"`
	Total int64 `json:"total"`
}

func (q *Queries) GetProductsByKeyword(ctx context.Context, arg GetProductsByKeywordParams) ([]GetProductsByKeywordRow, error) {
	rows, err := q.query(ctx, q.getProductsByKeywordStmt, getProductsByKeyword, arg.Keyword, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsByKeywordRow{}
	for rows.Next() {
		var i GetProductsByKeywordRow
		if err := rows.Scan(&i.ID, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSellers = `-- name: GetSellers :many
SELECT id, name, description, phone, address, logo_url, manager_id, create_uid, write_uid, create_date, write_date
FROM seller
WHERE CASE WHEN array_length($1::int8[], 1) > 0 THEN id = ANY($1::int8[]) ELSE TRUE END
`

func (q *Queries) GetSellers(ctx context.Context, ids []int64) ([]Seller, error) {
	rows, err := q.query(ctx, q.getSellersStmt, getSellers, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seller{}
	for rows.Next() {
		var i Seller
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Phone,
			&i.Address,
			&i.LogoUrl,
			&i.ManagerID,
			&i.CreateUid,
			&i.WriteUid,
			&i.CreateDate,
			&i.WriteDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUoms = `-- name: GetUoms :many
SELECT id, name, seller_id, create_uid, write_uid, create_date, write_date
FROM uom
WHERE CASE WHEN array_length($1::int8[], 1) > 0 THEN id = ANY($1::int8[]) ELSE TRUE END
`

func (q *Queries) GetUoms(ctx context.Context, ids []int64) ([]Uom, error) {
	rows, err := q.query(ctx, q.getUomsStmt, getUoms, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Uom{}
	for rows.Next() {
		var i Uom
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SellerID,
			&i.CreateUid,
			&i.WriteUid,
			&i.CreateDate,
			&i.WriteDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
